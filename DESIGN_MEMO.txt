This problem maps naturally to a graph: people are nodes and friendships are undirected edges. Graphs support bidirectional, many-to-many relationships without imposing hierarchy, which matches real social connections where a person can be connected to any number of others and cycles are common. Using an adjacency list (dictionary from name → Person) keeps lookups and updates straightforward: adding or finding a user is O(1) average with hashing, and each person holds a small list of direct neighbors (friends).

Lists or arrays alone are poor fits because they encode ordering rather than relationships; you would repeatedly scan to discover connections. Trees impose parent/child direction and acyclicity, which does not reflect mutual friendships or cliques; enforcing tree constraints would distort the model or block valid states.

Key trade-offs: adjacency lists are memory-efficient for sparse graphs (typical of large social networks) and make iteration over a person’s friends O(deg(v)). Checking whether two specific users are friends is O(deg(v)) with a list but could be improved to near O(1) if each Person stored a set instead of a list. I retained lists to provide deterministic printed order after sorting and to match the assignment’s example output style. Adding a friendship is O(1) amortized for user lookups plus O(1) expected to append, assuming duplicates are filtered. Printing the whole network is O(V log V + E log d) due to sorting names for stable, human-readable output. Overall, the adjacency-list design balances clarity, correctness, and typical performance characteristics for social graphs.
